===== kernel/include/cock/driver/vga.hpp =====
#ifndef VGA_H
#define VGA_H

#include <stddef.h>
#include <stdint.h>

namespace cock::driver {

typedef uint8_t vcolor;
typedef uint16_t vchar;


enum class VGAColor : vcolor {
	BLACK = 0,
	BLUE = 1,
	GREEN = 2,
	CYAN = 3,
	RED = 4,
	MAGENTA = 5,
	BROWN = 6,
	LIGHT_GRAY = 7,
	DARK_GRAY = 8,
	LIGHT_BLUE = 9,
	LIGHT_GREEN = 10,
	LIGHT_CYAN = 11,
	LIGHT_RED = 12,
	LIGHT_MAGENTA = 13,
	LIGHT_BROWN = 14,
	WHITE = 15,
};

class VGA {
  public:
	static constexpr size_t VGA_WIDTH = 80;
	static constexpr size_t VGA_HEIGHT = 25;
	static constexpr uintptr_t VGA_ADDRESS = 0xB8000;
	VGA();

	void setColor(VGAColor fg, VGAColor bg);
	void putEntryAt(unsigned char c, vcolor color, size_t x, size_t y);
	void putChar(char c);
	void write(const char *data, size_t size);
	void writeString(const char *data);
	void clear();
	void init();

  private:
	size_t row;
	size_t column;
	vcolor color;
	vchar volatile *buffer;

	void newline();
	void scroll();

	static constexpr vcolor vga_entry_color(VGAColor fg, VGAColor bg);
	static constexpr vchar vga_entry(unsigned char uc, vcolor color);
};

extern VGA vga_instance;

} // namespace driver

#endif // !VGA_H

===== kernel/include/cock/driver/video.hpp =====
#ifndef VIDEO_HPP
#define VIDEO_HPP
#include <stddef.h>

class Video {
  public:
	virtual void init() = 0;
	virtual void clear() = 0;
	virtual void putChar(char c) = 0;
	virtual void write(const char *data, size_t size) = 0;
	virtual void writeString(const char *data) = 0;
	virtual ~Video() = default;
};

#endif // !VIDEO_HPP

===== kernel/include/cock/utils/panic.hpp =====

#ifndef PANIC_HPP
#define PANIC_HPP

namespace cock::utils {

extern "C" {
__attribute__((noreturn)) void panic(const char *msg);
}

} // namespace cock::utils

#endif // !PANIC_HPP

===== kernel/include/cock/utils/ssp.hpp =====
#ifndef SSP_HPP
#define SSP_HPP

#include <stdint.h>


#if UINT32_MAX == UINTPTR_MAX
#define STACK_CHK_GUARD 0xE2DEE396
#else
#define STACK_CHK_GUARD 0x595E9FBD94FDA766
#endif

extern "C" {
__attribute__((noreturn)) void __stack_chk_fail(void);
}

#endif // !SSP_HPP

===== kernel/include/cock/core/arch.hpp =====
#ifndef ARCH_HPP
#define ARCH_HPP

namespace cock {

extern "C" {
void arch_init();
}

} // namespace cock

#endif // !ARCH_HPP

===== kernel/arch/x86/init.cpp =====
#include <cock/core/arch.hpp>
#include <cock/driver/vga.hpp>
#include "./gdt/gdt.hpp"
#include "./interrupt/idt/idt.hpp"

namespace cock::arch::x86 {

using cock::driver::vga_instance;

GDT gdt;
IDT idt;

void init_video(){
    vga_instance.init();
    vga_instance.clear();
}

extern "C" void arch_init(){
    init_video();
    gdt.init();
    idt.init();
}
    
}


===== kernel/arch/x86/boot/entry.s =====
; Declaration of constants for multiboot header
MBALIGN     equ 1 << 0              ; align loaded modules on page boundaries
MEMINFO     equ 1 << 1              ; provide memory map
MBFLAGS     equ MBALIGN | MEMINFO   ; this is Multiboot 'flag' field
MAGIC       equ 0x1BADB002          ; 'magic number' lets to the bootloader find the header
CHECKSUM    equ -(MAGIC + MBFLAGS)  ; this is the checksum of above

; Declaration of the multiboot header. This marks the whole program as a kernel.
section .multiboot
align 4
    dd MAGIC
    dd MBFLAGS
    dd CHECKSUM

; As multiboot standard has no  definition of the stack pointer. The next section is to allocate a small stack
section .bss
align 16
stack_bottom: 
    resb 16384 ; 16 KiB is reserved for stac KiB is reserved for stack
stack_top:


; Section of the kernel. You have complete use of computer resources
section .text
global _start:function (_start.end - _start)
_start:
    ; set the stack in the top
    mov esp, stack_top
    extern cock_main
    call cock_main

    cli             ; disables interrupts

; If the program has nothing to do then this put kernel into an infinite loop
.hang: hlt
    jmp .hang
.end:

===== kernel/arch/x86/linker.ld =====
ENTRY (_start)

SECTIONS{
    . = 2M;

    .text BLOCK(4K) : ALIGN(4K){
        *(.multiboot)
        *(.text)
    }

    .rodata BLOCK(4K) : ALIGN(4K){
        *(.rodata)
    }

    .data BLOCK(4K) : ALIGN(4K){
        *(.data)
    }

    .bss BLOCK(4K) : ALIGN(4K){
        *(COMMON)
        *(.bss)
    }

}

===== kernel/arch/x86/gdt/gdt.cpp =====
#include "gdt.hpp"

typedef long unsigned int addr_t;

extern "C" void gdt_flush(uintptr_t); // flush

namespace cock::arch::x86 {

GDT::GDT(){}

void GDT::init() {
	pointer.limit = (sizeof(Entry) * MAX_ENTRIES - 1);
	pointer.base = reinterpret_cast<uintptr_t>(&entries);

	setGate(0, 0, 0, 0, 0);				// NULL segment
	setGate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Kernel Code Segment
	setGate(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Kernel Data Segment
	setGate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User Code Segment
	setGate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User Data Segment

	gdt_flush(reinterpret_cast<uintptr_t>(&pointer));
}

void GDT::setGate(uint32_t num, uint32_t base, uint32_t limit, uint8_t access,
				  uint8_t gran) {
	entries[num].base_low = base & 0xFFFF;
	entries[num].base_middle = (base >> 0x10) & 0xFF;
	entries[num].base_high = (base >> 0x18) & 0xFF;

	entries[num].limit = (limit & 0xFFFF);
	entries[num].flags = (limit >> 0x10) & 0x0F;
	entries[num].flags |= gran & 0xF0;

	entries[num].access = access;
}

} // namespace arch::x86

===== kernel/arch/x86/gdt/gdt.hpp =====
#ifndef GDT_HPP
#define GDT_HPP
#include <stdint.h>

namespace cock::arch::x86 {
class GDT {
  public:
	typedef struct __attribute__((packed)) _gdt_entry_t {
		uint16_t limit;
		uint16_t base_low;
		uint8_t base_middle;
		uint8_t access;
		uint8_t flags;
		uint8_t base_high;
	} Entry;

	typedef struct __attribute__((packed)) _gdt_pointer_t {
		uint16_t limit;
		uintptr_t base;
	} Pointer;

  public:
	GDT();
	void init();

  private:
	static constexpr int MAX_ENTRIES = 5;
	Entry entries[MAX_ENTRIES];
	Pointer pointer;

	void setGate(uint32_t num, uint32_t base, uint32_t limit, uint8_t access,
				 uint8_t gran);
};

} // namespace arch::x86

#endif // !GDT_HPP

===== kernel/arch/x86/gdt/gdt.s =====
global gdt_flush
gdt_flush:
    mov eax, [esp+4]
    lgdt [eax]

    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    jmp 0x08:flush

flush:
    ret

===== kernel/arch/x86/crti.s =====
section .init
global _init
_init:
    push ebp
    mov ebp, esp

section .fini
global _fini
_fini:
    push ebp
    mov ebp, esp

===== kernel/arch/x86/make_iso.sh =====
mkdir -p build/isodir
mkdir -p build/isodir/boot
mkdir -p build/isodir/boot/grub

cp build/cock.bin build/isodir/boot/cock.bin
cat > build/isodir/boot/grub/grub.cfg << EOF
menuentry "cock" {
	multiboot /boot/cock.bin
}
EOF
grub-mkrescue -o build/cock.iso build/isodir

===== kernel/arch/x86/interrupt/irq/irq.hpp =====
#ifndef IRQ_HPP
#define IRQ_HPP

#include "../utils/functs.hpp"
#include <stddef.h>

namespace cock::arch::x86 {
using utils::InterruptRegisters;

constexpr size_t IRQ_NUM = 16;

extern "C" __attribute__((interrupt)) void
irq_handler(InterruptRegisters *regs);

} // namespace cock::arch::x86

#endif // !IRQ_HPP

===== kernel/arch/x86/interrupt/irq/irq.s =====
section .text

extern irq_handler

%macro irq 2
irq_stub_%1:
    cli
    push dword 0
    push dword %2
    jmp irq_common_stub
%endmacro

irq_common_stub:
    pusha
    mov eax, ds 
    push eax
    mov eax, cr2
    push eax

    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    push esp

    call irq_handler

    add esp, 8 
    pop ebx
    mov ds, bx
    mov es, bx
    mov fs, bx
    mov gs, bx

    popa
    add esp, 8
    sti 
    iret

irq 0, 32
irq 1, 33
irq 2, 34
irq 3, 35
irq 4, 36
irq 5, 37
irq 6, 38
irq 7, 39
irq 8, 40
irq 9, 41
irq 10, 42
irq 11, 43
irq 12, 44
irq 13, 45
irq 14, 46
irq 15, 47


section .rodata

%define IRQ_COUNT 16

global irq_stub_table
irq_stub_table:
%assign i 0
%rep IRQ_COUNT
    dd irq_stub_%+i
%assign i i+1
%endrep

===== kernel/arch/x86/interrupt/irq/irq.cpp =====
#include "irq.hpp"
#include "../pic/pic.hpp"
#include <cock/utils/panic.hpp>

namespace cock::arch::x86 {

using utils::InterruptRegisters;

typedef void (*IrqRoutine)(InterruptRegisters *reg);

using utils::out_port_b;
using cock::utils::panic;

IrqRoutine irq_routines[16] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

void irq_install_handler(int irq, IrqRoutine handler) {
	irq_routines[irq] = handler;
}

void irq_uninstall_handler(int irq) { irq_routines[irq] = 0; }

extern "C" __attribute__((interrupt)) void
irq_handler(InterruptRegisters *regs) {
	if (regs->int_no < 32 || regs->int_no > 48) panic("Invalid Interrupt Number.");
	IrqRoutine handler;

	int handler_index = regs->int_no - 32;

	if (handler_index < 16) {
		handler = irq_routines[handler_index];

		if (handler) handler(regs);
		if (regs->int_no >= 40) out_port_b((uint16_t)PIC2::COMMAND, 0x20);
		out_port_b((uint16_t)PIC1::COMMAND, 0x20);
	}
}

} // namespace cock::arch::x86

===== kernel/arch/x86/interrupt/isr/isr.s =====
section .text

extern isr_handler

%macro isr_err_stub 1
isr_stub_%1:
    cli
    push dword 0
    push dword %1
    jmp isr_common_stub
    iret 
%endmacro

%macro isr_no_err_stub 1
isr_stub_%1:
    cli
    push dword %1
    jmp isr_common_stub
%endmacro

isr_common_stub:
    pusha
    mov eax, ds 
    push eax
    mov eax, cr2
    push eax

    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    push esp

    call isr_handler

    add esp, 8 
    pop ebx
    mov ds, bx
    mov es, bx
    mov fs, bx
    mov gs, bx

    popa
    add esp, 8
    sti 
    iret


isr_no_err_stub 0
isr_no_err_stub 1
isr_no_err_stub 2
isr_no_err_stub 3
isr_no_err_stub 4
isr_no_err_stub 5
isr_no_err_stub 6
isr_no_err_stub 7
isr_err_stub    8
isr_no_err_stub 9
isr_err_stub    10
isr_err_stub    11
isr_err_stub    12
isr_err_stub    13
isr_err_stub    14
isr_no_err_stub 15
isr_no_err_stub 16
isr_err_stub    17
isr_no_err_stub 18
isr_no_err_stub 19
isr_no_err_stub 20
isr_no_err_stub 21
isr_no_err_stub 22
isr_no_err_stub 23
isr_no_err_stub 24
isr_no_err_stub 25
isr_no_err_stub 26
isr_no_err_stub 27
isr_no_err_stub 28
isr_no_err_stub 29
isr_err_stub    30
isr_no_err_stub 31

global isr_stub_128
isr_no_err_stub 128

global isr_stub_177
isr_no_err_stub 177


section .rodata

%define ISR_COUNT 32    

global isr_stub_table
isr_stub_table:
%assign i 0
%rep ISR_COUNT
    dd isr_stub_%+i
%assign i i+1
%endrep

===== kernel/arch/x86/interrupt/isr/isr.cpp =====
#include "isr.hpp"
#include <stdio.h>

#define ETERNAL                                                                \
	;                                                                          \
	;

namespace cock::arch::x86 {
constexpr const char *EXCEPTION_MESSAGES[] = {"Division by Zero",
											  "Debug",
											  "Non Maskable Interrupt",
											  "Breakpoint",
											  "Into Detected Overflow",
											  "Out of Bounds",
											  "Invalid Opcode",
											  "No Coprocessor",
											  "Double Fault",
											  "Bad TSS",
											  "Segment Not Present",
											  "Stack Fault",
											  "General Protection Fault",
											  "Page Fault",
											  "Unknow Interrupt",
											  "Coprocessor Fault",
											  "Alignment Fault",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved",
											  "Reserved"};

extern "C" __attribute__((interrupt)) void
isr_handler(InterruptRegisters *regs) {
	if (regs->int_no < ISR_NUM) {
		puts(EXCEPTION_MESSAGES[regs->int_no]);
		puts("System Exception Halted");
		for (ETERNAL)
			;
	}
}

} // namespace cock::arch::x86

===== kernel/arch/x86/interrupt/isr/isr.hpp =====
#ifndef ISR_HPP
#define ISR_HPP

#include "../utils/functs.hpp"



namespace cock::arch::x86 {

using utils::InterruptRegisters;

constexpr int ISR_NUM = 32;

extern "C" __attribute__((interrupt)) void
isr_handler(InterruptRegisters *regs);

}

#endif // !ISR_HPP

===== kernel/arch/x86/interrupt/idt/idt.hpp =====
#ifndef IDT_HPP
#define IDT_HPP
#include <stdint.h>
#include "../isr/isr.hpp"
#include "../irq/irq.hpp"

namespace cock::arch::x86 {
class IDT {
  public:
	typedef struct __attribute__((packed)) _idt_entry_t {
		uint16_t base_low;
		uint16_t selector;
		uint8_t reserved;
		uint8_t flags;
		uint16_t base_high;
	} Entry;

	typedef struct __attribute__((packed)) _idt_descriptor_t {
		uint16_t limit;
		uintptr_t base;
	} Descriptor;

  public:
	IDT();
	void init();

  private:
	static constexpr int MAX_ENTRIES = 256;
	__attribute__((aligned(0x10))) Entry entries[MAX_ENTRIES];
	Descriptor descriptor;

	void setGate(uint32_t num, uint32_t base, uint32_t selector, uint8_t flags);
};

} // namespace arch::x86

#endif // !IDT_HPP

===== kernel/arch/x86/interrupt/idt/idt.s =====
global idt_flush
idt_flush:
    mov eax, [esp+4]
    lidt [eax]
    sti
    ret


===== kernel/arch/x86/interrupt/idt/idt.cpp =====
#include "idt.hpp"
#include "../pic/pic.hpp"
#include <stddef.h>
#include <stdint.h>
#include <string.h>

extern "C" void *irq_stub_table[];
extern "C" void *isr_stub_table[];
extern "C" void *isr_stub_128;
extern "C" void *isr_stub_177;

extern "C" void idt_flush(uintptr_t);
namespace cock::arch::x86 {


/** Initializing PICs
 * */

IDT::IDT() {}

void IDT::init() {
	size_t entries_size = sizeof(Entry) * MAX_ENTRIES;
	descriptor.limit = entries_size - 1;
	descriptor.base = reinterpret_cast<uintptr_t>(&entries);
	memset(&entries, 0, entries_size);

	PIC_remap(0x20, 0x28);

	for (size_t isr = 0; isr < ISR_NUM; isr++)
		setGate(isr,
				reinterpret_cast<uint32_t>(isr_stub_table[isr]), 0x08,
				0x8E);

    for(size_t irq = 0; irq < IRQ_NUM; irq++ )
		setGate(ISR_NUM + irq,
				reinterpret_cast<uint32_t>(irq_stub_table[irq]), 0x08,
				0x8E);
	setGate(128, reinterpret_cast<uint32_t>(&isr_stub_128), 0x08, 0x8E);
	setGate(177, reinterpret_cast<uint32_t>(&isr_stub_177), 0x08, 0x8E);

	idt_flush(reinterpret_cast<uintptr_t>(&descriptor));
}

void IDT::setGate(uint32_t num, uint32_t base, uint32_t selector,
				  uint8_t flags) {
	entries[num].base_low = base & 0xFFFF;
	entries[num].base_high = (base >> 0x10) & 0xFFFF;
	entries[num].selector = selector;
	entries[num].reserved = 0;
	entries[num].flags = flags | 0x60;
}

} // namespace arch::x86

===== kernel/arch/x86/interrupt/utils/functs.hpp =====
#ifndef FUNCTS_HPP
#define FUNCTS_HPP

#include <stdint.h>

namespace cock::arch::x86::utils {

typedef struct _interrupt_registers_t {
    uint32_t cr2;
    uint32_t ds;
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
    uint32_t int_no, err_code;
    uint32_t eip, cs, eflags, useresp, ss;
} InterruptRegisters;

/**
 * Outputs a byte to the given port
 * */
void out_port_b(uint16_t port, uint8_t value);

}

#endif // !FUNCTS_HPP

===== kernel/arch/x86/interrupt/utils/functs.cpp =====
#include "functs.hpp"

namespace cock::arch::x86::utils {

void out_port_b(uint16_t port, uint8_t value) {
	asm volatile("outb %0, %1" : : "a"(value), "Nd"(port));
}

} // namespace arch::x86::utils

===== kernel/arch/x86/interrupt/pic/pic.cpp =====
#include "pic.hpp"

#include "../utils/functs.hpp"

namespace cock::arch::x86 {

using utils::out_port_b;

void PIC_remap(uint8_t master_offset, uint8_t slave_offset) {
	out_port_b((uint16_t)PIC1::COMMAND, static_cast<uint8_t>(ICW1::INIT) |
											static_cast<uint8_t>(ICW1::ICW4));
	out_port_b((uint16_t)PIC2::COMMAND, static_cast<uint8_t>(ICW1::INIT) |
											static_cast<uint8_t>(ICW1::ICW4));

	out_port_b((uint16_t)PIC1::DATA, master_offset);
	out_port_b((uint16_t)PIC2::DATA, slave_offset);

	out_port_b((uint16_t)PIC1::DATA, 1 << CASCADE_IRQ);
	out_port_b((uint16_t)PIC2::DATA, 0x02);

	out_port_b((uint16_t)PIC1::DATA, static_cast<uint8_t>(ICW4::EES));
	out_port_b((uint16_t)PIC2::DATA, static_cast<uint8_t>(ICW4::EES));

	// unmask both PICs
	out_port_b((uint16_t)PIC1::DATA, 0x0);
	out_port_b((uint16_t)PIC2::DATA, 0x0);
}

}

===== kernel/arch/x86/interrupt/pic/pic.hpp =====
#ifndef PIC_HPP
#define PIC_HPP

#include <stddef.h>
#include <stdint.h>

namespace cock::arch::x86 {

constexpr int CASCADE_IRQ = 2;

/** Master PIC
 * */
enum class PIC1 : uint16_t {
	PORT = 0x20,
	COMMAND = PIC1::PORT,
	DATA = PIC1::PORT + 1
};

/** Slave PIC
 * */
enum class PIC2 : uint16_t {
	PORT = 0xA0,
	COMMAND = PIC2::PORT,
	DATA = PIC2::PORT + 1
};

enum class ICW1 : uint8_t {
	ICW4 = 0x01, // ICW4 will be present
	SINGLE = 0x02, // Single (cascade) mode
	INTERVAL4 = 0x04, // calls address interval 4
	LEVEL = 0x08, // Level triggered (edge) mode
	INIT = 0x10, // initialization
};

enum class ICW4 : uint8_t {
	EES = 0x01, // 8086 mode
	AUTO = 0x02, // Auto End Of Interruption
	BUF_SLAVE = 0x04, // Buffered mode - slave
	BUF_MASTER = 0x08, // Buffered mode - master
	SFNM = 0x10, // Special fully nested (not)
};


void PIC_remap(uint8_t master_offset, uint8_t slave_offset);

}

#endif // !PIC_HPP

===== kernel/arch/x86/crtn.s =====
section .init
    pop ebp
    ret

section .fini
    pop ebp
    ret

===== kernel/driver/vga.cpp =====
#include <cock/driver/vga.hpp>
#include <string.h>

namespace cock::driver {

constexpr VGAColor DEFAULT_BG_COLOR = VGAColor::BLACK;
constexpr VGAColor DEFAULT_FG_COLOR = VGAColor::GREEN;
constexpr char INITIAL_ROW = 0;
constexpr char INITIAL_COL = 0;
constexpr char NEWLINE = '\n';
constexpr char EMPTY = ' ';
constexpr size_t STEP = 1;

VGA vga_instance;

VGA::VGA()
	: row(INITIAL_ROW), column(INITIAL_COL),
	  color(vga_entry_color(DEFAULT_FG_COLOR, DEFAULT_BG_COLOR)),
	  buffer(reinterpret_cast<vchar *>(VGA_ADDRESS)) {};

void VGA::init() {
	row = INITIAL_ROW;
	column = INITIAL_COL;
	color = vga_entry_color(DEFAULT_FG_COLOR, DEFAULT_BG_COLOR);
	buffer = reinterpret_cast<vchar *>(VGA_ADDRESS);
}

void VGA::setColor(VGAColor fg, VGAColor bg) {
	color = vga_entry_color(fg, bg);
}

void VGA::putEntryAt(unsigned char c, vcolor color, size_t x, size_t y) {
	const size_t index = y * VGA_WIDTH + x;
	buffer[index] = vga_entry(c, color);
}

void VGA::putChar(char c) {
	if (c == NEWLINE) {
		newline();
		return;
	}
	putEntryAt(c, color, column, row);
	if (++column == VGA_WIDTH) {
		column = INITIAL_COL;
		newline();
	}
}

void VGA::write(const char *data, size_t size) {
	for (size_t i = 0; i < size; i++)
		putChar(data[i]);
}

void VGA::writeString(const char *data) { write(data, strlen(data)); }

void VGA::clear() {
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
		for (size_t x = 0; x < VGA_WIDTH; x++) {
			const size_t index = y * VGA_WIDTH + x;
			buffer[index] = vga_entry(EMPTY, color);
		}
	}
	row = INITIAL_ROW;
	column = INITIAL_COL;
}

void VGA::newline() {
	column = INITIAL_COL;
	if (++row == VGA_HEIGHT) {
		scroll();
		row = VGA_HEIGHT - STEP;
	}
}

void VGA::scroll() {
	for (size_t y = 1; y < VGA_HEIGHT; y++) {
		for (size_t x = 0; x < VGA_WIDTH; x++) {
			buffer[(y - STEP) * VGA_WIDTH + x] = buffer[y * VGA_WIDTH + x];
		}
	}
	for (size_t x = 0; x < VGA_WIDTH; x++) {
		buffer[(VGA_HEIGHT - STEP) * VGA_WIDTH + x] = vga_entry(EMPTY, color);
	}
}

constexpr vcolor VGA::vga_entry_color(VGAColor fg, VGAColor bg) {
	return static_cast<vcolor>(fg) | (static_cast<vcolor>(bg) << 4);
}

constexpr vchar VGA::vga_entry(unsigned char uc, vcolor color) {
	return static_cast<vchar>(uc) | static_cast<vchar>(color) << 8;
}

} // namespace cock::driver

===== kernel/utils/panic.cpp =====
#include <cock/utils/panic.hpp>
#include <stdio.h>

#define ETERNAL ;;

namespace cock::utils {
constexpr const char *KERNEL_PANIC_MESSAGE = "cock panic: %s\n";

__attribute__((noreturn)) void panic(const char *msg) {
	printf(KERNEL_PANIC_MESSAGE, msg);
	for (ETERNAL)
		__asm__ volatile("cli; hlt");
	__builtin_unreachable();
}
} // namespace cock::utils

===== kernel/utils/ssp.cpp =====
#include <cock/utils/panic.hpp>
#include <cock/utils/ssp.hpp>

using cock::utils::panic;

uintptr_t __stack_chk_guard = STACK_CHK_GUARD;

extern "C" __attribute__((noreturn)) void __stack_chk_fail(void) {
#if __STDC_HOSTED__
	abort();
#elif __is_cock_kernel
	panic("Stack smashing detected");
#endif
	for (;;)
		__asm__ volatile("cli; hlt");
}

===== kernel/core/cock.cpp =====
#include <cock/core/arch.hpp>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

#if defined(__linux__)
#error "You are not using a  cross-compiler"
#endif

#define VERSION 0

namespace cock {

extern "C" void cock_main(void) {
    arch_init();
    puts("GDT is initialized");;
    printf("Welcome to microcock V%d\n", VERSION);
    puts("Semillero de Linux");
    puts("SEIC");
}

}

// TODO: Create initialized header

===== libc/include/sys/cdefs.h =====
#ifndef SYS_CDEFS_H
#define SYS_CDEFS_H 1 1

#define __cock_libc 1

#endif // !SYS_CDEFS_H

===== libc/include/stdio.h =====
#ifndef STDIO_H
#define STDIO_H

#ifndef EOF
#define EOF (-1)
#endif // !EOF

extern "C" {
int printf(const char *__restrict, ...);
int putchar(int);
int puts(const char *);
}

#endif // !STDIO_H

===== libc/include/stdlib.h =====
#ifndef STDLIB_H
#define STDLIB_H

#include <sys/cdefs.h>

extern "C" {
__attribute__((__noreturn__)) void abort(void);
}

#endif // !STDLIB_H

===== libc/include/string.h =====
#ifndef STRING_H
#define STRING_H

#include <stddef.h>
#include <sys/cdefs.h>

extern "C" {
int memcmp(const void *s1, const void *s2, size_t size);
void *memcpy(void *__restrict dest, const void *__restrict src,
			 size_t n);
void *memmove(void *dest, const void *src, size_t size);
void *memset(void *str, int c, size_t n);
size_t strlen(const char *str);
}

#endif // STRING_H

===== libc/stdio/putchar.cpp =====
#include <stdio.h>
#if defined(__is_libk)
#include <cock/driver/vga.hpp>
#endif

using cock::driver::vga_instance;

int putchar(int ic) {
#if defined(__is_libk)
	char c = (char)ic;
    vga_instance.write(&c, sizeof(c));
#else
// TODO: implement stdio and write a systemcall
#endif
	return ic;
}

===== libc/stdio/printf.cpp =====
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

// Max int32
constexpr size_t MAX_NUMBER_SIZE = 64;
constexpr size_t MAX_STRING_SIZE = 1024;

constexpr const char *DIGIT_DICTIONARY = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
constexpr const char *NULL_STRING_MESSAGE = "(null)";
constexpr char NEGATIVE_PREFIX = '-';
constexpr char SPEC_DELIMITER = '%';
constexpr char END_OF_STRING = '\0';
constexpr char CHAR_ZERO = '0';
constexpr int INT_ZERO = 0;
constexpr size_t STEP = 1;

constexpr int DEFAULT_INDEX = 0;
constexpr int SUCCESS = 0;
constexpr int ERROR = -1;
constexpr int EMPTY = 0;

// TYPES
typedef int (*StreamWriteBufferFunction)(const char *);

typedef enum _spec_type_e {
	SPEC_DIGIT = 'd',
	SPEC_UNSIGNED = 'u',
	SPEC_HEX = 'x',
	SPEC_OCTAL = 'o',
	SPEC_CHAR = 'c',
	SPEC_STRING = 's'
} SpecType;

typedef struct _stream_t {
	size_t capacity;
	size_t index;
	char *buffer;
	StreamWriteBufferFunction write_all;
} Stream;

// Auxiliar functions
/**
 * Writes a buffer char by char
 * returns the length of the written data
 * */
static int print(const char *data) {
	size_t length = strlen(data);
	const unsigned char *bytes = (const unsigned char *)data;
	for (size_t i = 0; i < length; i++) {
		if (putchar(bytes[i]) == EOF) return i;
	}
	return (length);
}

/**
 * Try to print the buffer.
 *  returns:
 *      - 0 on success
 *      - non-0 on failure
 * */
static int print_stream_buffer(Stream *stream) {
	// Sets the final character as \0
	stream->buffer[stream->index] = END_OF_STRING;
	// writes the buffer and return 1 on failure
	size_t written = (size_t)stream->write_all(stream->buffer);
	if (written != stream->index) return ERROR;

	// Clears the buffer
	memset(stream->buffer, EMPTY, stream->capacity);
	stream->index = DEFAULT_INDEX;
	return SUCCESS;
}

/**
 * If not enough space is available and forwards the return code
 * */
static int push_to_buffer(Stream *stream, char c) {
	stream->buffer[stream->index++] = c;

	// if buffer is full, flushes it.
	if (stream->index == stream->capacity - 2) {
		int result = print_stream_buffer(stream);
		if (result != SUCCESS) return result;
	}
	return SUCCESS;
}

/**
 * If there is few space after pushing the string or at the end,
 * it will push it to the buffer and try to flush it.
 * */
static int push_all_to_buffer(Stream *stream, const char *str) {
	int result;
	for (char c = *str; c != END_OF_STRING; c = *++str) {
		result = push_to_buffer(stream, c);
		if (result != SUCCESS) return result;
	}
	return SUCCESS;
}

/**
 * Pushes an Integer into the buffer,
 * if there's is not enough space writes it and flushes the buffer
 * */
static void push_int_to_buffer(Stream *stream, unsigned int val,
							   unsigned int base, int is_signed) {
	static char buffer[MAX_NUMBER_SIZE] = {EMPTY};
	int i = MAX_NUMBER_SIZE - 1;
	buffer[i] = END_OF_STRING;

	if (is_signed) {
		int sval = (int)val;
		if (sval < INT_ZERO) {
			push_to_buffer(stream, NEGATIVE_PREFIX);
			val = (unsigned int)(-sval);
		} else {
			val = sval;
		}
	}

	if (val == INT_ZERO) {
		push_to_buffer(stream, CHAR_ZERO);
		return;
	}

	while (val && i > INT_ZERO) {
		buffer[--i] = DIGIT_DICTIONARY[val % base];
		val /= base;
	}

	push_all_to_buffer(stream, &buffer[i]);
}

static int int_flag_to_base(SpecType flag) {
	switch (flag) {
		case SPEC_DIGIT:
		case SPEC_UNSIGNED:
			return 10;
		case SPEC_HEX:
			return 16;
		case SPEC_OCTAL:
			return 8;
		default:
			return 10;
	}
}

int vprintf(Stream *stream, const char *format, va_list args) {
	for (size_t i = 0; format[i] != END_OF_STRING; i++) {
		char current = format[i];

		// Any char
		if (current != SPEC_DELIMITER) {
			push_to_buffer(stream, current);
			continue;
		}

		// %%
		if (format[i + STEP] == SPEC_DELIMITER) {
			push_to_buffer(stream, SPEC_DELIMITER);
			i++;
			continue;
		}

		SpecType spec = (SpecType)format[++i];
		int is_signed = 0;

		switch (spec) {
			case SPEC_DIGIT: {
				int val = va_arg(args, int);
				is_signed = 1;
				push_int_to_buffer(stream, val, int_flag_to_base(spec),
								   is_signed);
				break;
			}
			case SPEC_UNSIGNED:
			case SPEC_HEX:
			case SPEC_OCTAL: {
				unsigned int val = va_arg(args, unsigned int);
				push_int_to_buffer(stream, val, int_flag_to_base(spec),
								   is_signed);
				break;
			}
			case SPEC_CHAR: {
				int c = va_arg(args, int);
				push_to_buffer(stream, (char)c);
				break;
			}
			case SPEC_STRING: {
				const char *str = va_arg(args, const char *);
				push_all_to_buffer(stream, str ? str : NULL_STRING_MESSAGE);
				break;
			}
			default:
				push_to_buffer(stream, SPEC_DELIMITER);
				push_to_buffer(stream, spec);
				break;
		}
	}
	int r = print_stream_buffer(stream);
	return r;
}

int printf(const char *__restrict format, ...) {
	va_list args;
	va_start(args, format);
	char buffer[MAX_STRING_SIZE];
	Stream stream = {.capacity = sizeof(buffer),
					 .index = DEFAULT_INDEX,
					 .buffer = buffer,
					 .write_all = print};
	int result = vprintf(&stream, format, args);
	va_end(args);
	return result;
}

===== libc/stdio/puts.cpp =====
#include <stdio.h>

int puts(const char *str) { return printf("%s\n", str); }

===== libc/string/strlen.cpp =====
#include <string.h>

size_t strlen(const char *str) {
	size_t len = 0;
	while (str[len])
		len++;
	return len;
}

===== libc/string/memcmp.cpp =====
#include <string.h>

int memcmp(const void *aptr, const void *bptr, size_t size) {
	const unsigned char *a = (const unsigned char *)aptr;
	const unsigned char *b = (const unsigned char *)bptr;
	for (size_t i = 0; i < size; i++) {
		if (a[i] < b[i]) return -1;
		else if (b[i] < a[i]) return 1;
	}
	return 0;
}

===== libc/string/memcpy.cpp =====
#include <string.h>
 
void *memcpy(void *dest, const void *src, size_t n) {
    unsigned char *d = (unsigned char *)dest;
    const unsigned char *s = (const unsigned char *)src;
    for (size_t i = 0; i < n; i++)
        d[i] = s[i];
    return dest;
}

===== libc/string/memmove.cpp =====
#include <string.h>

void *memmove(void *destptr, const void *srcptr, size_t size) {
	unsigned char *dest = (unsigned char *)destptr;
	const unsigned char *src = (unsigned char *)srcptr;
	if (dest < src) {
		for (size_t i = 0; i < size; i++)
			dest[i] = src[i];
	} else {
		for (size_t i = size; i != 0; i--)
			dest[i - 1] = src[i - 1];
	}

	return destptr;
}

===== libc/string/memset.cpp =====
#include <string.h>

void *memset(void *bufptr, int value, size_t size) {
	unsigned char *buf = (unsigned char *)bufptr;
	for (size_t i = 0; i < size; i++)
		buf[i] = (unsigned char)value;
	return bufptr;
}

===== libc/stdlib/abort.cpp =====
#include "cock/utils/panic.hpp"
#include <stdio.h>
#include <stdlib.h>

#define ETERNAL ;;

using cock::utils::panic;

__attribute__((__noreturn__)) void abort(void) {
#if defined(__is_libk)
	panic("abort()\n");
#else
	// TODO: CREATE a proper kernel panic
	printf("abort()\n");
#endif
	asm volatile("hlt");
	for (ETERNAL);
	__builtin_unreachable();
}

